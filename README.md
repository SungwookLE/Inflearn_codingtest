# CodingTest Prepare

--- 
 - Lecture: IT 기업 취업을 위한: 코딩 테스트 혼자서 정복하기 (INFLEARN, 26,400원)
 - Date: '22.3/9~
 - Writer: Sungwook LE
 - Language: `C++`
 - 목표:
    1. 문제가 요구하는 알고리즘을 파악할 수 있다.
    2. 최소한의 문법으로 최대한 깔끔한 코드를 작성할 수 있다. 
    3. 공통적으로 출제되는 문제의 **템플릿**을 작성/이해하고 이를 통해 문제를 풀자.
--- 

## 1. Dynamic Programming 동적프로그래밍
- Dynamic Programming = **분할정복 프로그래밍**
- 분할정복 풀이: `Bottom-up` 방식으로 점화식(`recurrence relation`)을 유도하여 풀자
    - 문제를 직접 풀려고 `if`문을 생각하게 되면, 여러 예외조건에 막혀 문제를 풀 수 없게된다는 것을 명심
    - 분할정복 문제는 배열을 이용해서 풀게되는데, 이 때!, `0` 번째 케이스에 대한 값을 0과 같은 default 값을 넣어줌으로써 `trivial case` 에 대한 값을 명시적으로 배열을 채워서 풀자.
    - Top-down 방식으로 풀어야하는 문제도 있으나, 대부분 Bottom-up 방식이 풀기 쉽다.
### 1-1. 분할정복 풀이를 위한 점화식
1. 수열의 n번째 값 $a_n$을 구하기 위해 따라야 하는 규칙
2. $a_n$을 구하기 위해서는, $a_1$부터 순서대로 계산해야 함

### 1-2. 점화식은 Bottom-Up으로 풀자 
- 점화식이 아래와 같을 때, $a_5$를 구하여라.
    - $a_1 = 3$ 
    - $a_n = 2a_{n-1}-4$

- Solution: Bottom-up 접근

    ![](./img/2022-03-09-17-19-13.png)

### 1-3. 배열을 이용한 점화식 풀이 방법
![](./img/2022-03-09-17-21-22.png)
- [dp_sequence.cpp](./DynamicProgramming/dp_sequence.cpp)
- 실제 코딩테스트 문제는 `점화식`을 주지 않으니, 직접 유도해야 한다.

### 1-4. 연습문제(1차원 DP)
- 큰 문제를 작은 문제부터 해결하여 계산하기: 1차원 배열
#### 1. 특정 금액을 만들 수 있는 동전의 최소개수를 찾아라
![](./img/2022-03-09-17-39-39.png)
    - 풀이: 20원으로 조합되기 위한 조합의 수는 15원의 조합 + 1 또는 17원의 조합 + 1 의 조합의 수를 갖는다.
    ![](./img/2022-03-09-17-44-42.png)
    - 점화식:
    ![](./img/2022-03-09-17-47-50.png)
    - 배열 설계:
    ![](./img/2022-03-09-18-38-04.png)
    ![](./img/2022-03-12-16-32-57.png)
    - 코드: [dp_changecoin.cpp](./DynamicProgramming/dp_changecoin.cpp)
        
### 1-5. 실전문제(2차원 DP)
- 큰 문제를 작은 문제부터 해결하여 계산하기: 2차원 배열
#### 1. 가방에 담을 수 있는 보석의 최대 값어치를 담아 훔쳐라
![](./img/2022-03-09-19-44-08.png)
- 풀이: 작은 문제들을 풀어나가는 과정을 통해 N=4, K=14 위치의 값어치를 찾아보는 것을 생각해보자.
    ![](./img/2022-03-09-20-15-54.png)
    ![](./img/2022-03-09-20-25-14.png)
    ![](./img/2022-03-09-20-24-47.png)
    ![](./img/2022-03-12-16-33-35.png)
- 점화식: 
    ```c++
    if (j >= W)
        DP[i][j] = max(DP[i-1][j], DP[i-1][j-W]+current_price)
     // 배낭의 무게 허용량(j)이 보석의 무게(W)보다 크다면, 새로운 보석을 넣었을 때와 넣지 않았을 때의 max값이 가방에 들어갈 수 있는 보석의 최대값어치이다. 
    else if (j < W)
        DP[i][j] = DP[i-1][j]
    // 보석의 무게(W)가 배낭 허용량(j)보다 무거운 케이스
    ```
- 코드: [dp_backpack_ruby.cpp](./DynamicProgramming/dp_backpack_ruby.cpp)

#### 2. 주어진 두개의 문자열의 LCS(Longest Common Sequence)를 찾아라
![](./img/2022-03-11-23-34-23.png)
 - 풀이: 작은 문제들을 풀어나가는 과정을 통해 `LCS`를 찾아내자.
 - 문제의 조건에서 `LCS`는 연속적일 문자열일 필요는 없었다.
 - 점화식:
    ![](./img/2022-03-10-23-53-01.png)
    ![](./img/2022-03-10-23-51-44.png)

    ```c++
    vector<vector<int>> DP(A.length()+1, vector<int>(B.length()+1,0));
    string A_token_last;
    for(int i = 1 ; i <= A.length(); ++i){
        A_token_last = A[i-1];
        string B_token_last;
        for(int j = 1 ; j <= B.length(); ++j){
            B_token_last = B[j-1];
            if (A_token_last == B_token_last)
                DP[i][j] = DP[i-1][j-1]+1; 
    //두 문자열의 마지막 문자가 같다면, LCS("A문자열에서 마지막 문자 제거", "B문자열에서 마지막 문자 제거") + 1 의 값의 DP[i][j]의 LCS 최대값
            else
                DP[i][j] = max(DP[i-1][j], DP[i][j-1]);
    //두 문자열의 마지막 문자가 다르다면, max(LCS("A문자열", "B문자열에서 마지막 문자 제거"), LCS("A문자열에서 마지막 문자 제거", "B문자열"))
        }
    }
    ```
 - 코드: [dp_LCS.cpp](./DynamicProgramming/dp_LCS.cpp)

#### 3. 프로그래머스 문제: 최소 N을 사용하여 주어진 number를 만드는 개수를 찾아라
 - 문제: [N으로표현](https://programmers.co.kr/learn/courses/30/lessons/42895)
 - 문제 설명
 > 아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.
 > * 12 = 5 + 5 + (5 / 5) + (5 / 5)
 12 = 55 / 5 + 5 / 5
 12 = (55 + 5) / 5
 > * 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.
 이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요.
 > * 제한사항
 N은 1 이상 9 이하입니다.
 number는 1 이상 32,000 이하입니다. 
 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
 최솟값이 8보다 크면 -1을 return 합니다.

- 문제 풀이: bottom-up으로 풀 수 있는 배열을 설계하여 풀자(`점화식`)
    ![](./img/2022-03-12-16-31-25.png)

- 코드: [dp_programmers_N](./DynamicProgramming/dp_programmers_N.cpp)

#### 4. 프로그래머스 문제: 삼각형의 최대 합을 찾아라
 - 문제: [정수삼각형](https://programmers.co.kr/learn/courses/30/lessons/43105)
 - 문제 설명
 ![](./img/2022-03-12-16-02-41.png)
 > * 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.
 > 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.
 > * 제한사항
 삼각형의 높이는 1 이상 500 이하입니다.
 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다

 - 문제 풀이: bottom-up으로 풀 수 있는 배열을 설계하여 풀자(`점화식`)
 - 처음 생각한 방식은 삼각형의 위에서 부터 모든 경로에 대한 경우의 수를 따지는 것은 동적프로그래밍이라기 보다는 브루트포스 방식(모든 경우를 naive하게 전부 계산)가 된다.
 - 삼각형의 밑변에서 부터 시작하여 최대 합이 나오는 것을 선택해주면 모든 경우의 수를 따지지 않고서 삼각형 경로의 최대합을 구할 수 있다. 
    ```
    DP[i][j] = max( DP[i-1][j] + triangle[height-i][j-1],DP[i-1][j+1] + triangle[height-i][j-1]);
    ```
    ![](./img/2022-03-12-16-31-56.png)

 - 코드: [dp_programmers_tri](./DynamicProgramming/dp_programmers_tri.cpp)


## 2. 그래프 탐색 알고리즘
 - 그래프는 노드(상태)와 엣지로 이루어져 있음
 - 그래프 탐색 알고리즘: BFS(너비우선탐색), DFS(깊이우선탐색) 알고리즘으로 나뉜다.
    1. BFS(Breadth First Search)
        - 탐색 후 방문
        - 큐(`queue`)의 역할: 탐색 노드 (방문 예정 노드) 저장
        - 큐: Last In Last Out
    2. DFS(Depth First Search)
        - 즉시 방문
        - 스택(`stack`)의 역할: 지금까지 방문한 노드 모두 저장 (Trace)
        - 스택: Last In First Out

### 2-1. 개념 문제

#### 1. 다리로 이어져 있는 섬을 찾아가자
- ![](./img/2022-03-13-10-18-06.png) 지웅이는 A위치에서 목적지인 F까지 이동하여야 한다.

    ##### BFS: 가까이 있는 섬부터 탐색하기 (너비 우선 탐색)
    
    - `큐(queue)`를 활용한 BFS 문제풀이
    - 참고: `큐(queue)`에 있는 노드는 아직 방문하지 않은 노드이고(`candidates`), 큐에서 꺼낼 때 방문
    1. default 상태 (어느 섬에도 있지 않음)
            - ![](./img/2022-03-13-10-23-14.png)
    2. A섬에 탐색을 시작
            - ![](./img/2022-03-13-10-23-24.png)
            - ![](./img/2022-03-13-10-25-32.png)
            - ![](./img/2022-03-13-10-25-15.png)
            - ![](./img/2022-03-13-10-26-07.png)
            - ![](./img/2022-03-13-10-26-14.png)
    3. B섬에 방문하여 탐색을 시작
            - ![](./img/2022-03-13-10-28-44.png)
            - ![](./img/2022-03-13-10-28-52.png)
            - ![](./img/2022-03-13-10-29-53.png)
            - ![](./img/2022-03-13-10-30-03.png)
    4. C섬에 방문하여 탐색을 시작
            - ![](./img/2022-03-13-10-30-45.png)
            - ![](./img/2022-03-13-10-32-17.png)
            - ![](./img/2022-03-13-10-32-26.png)
    5. D섬에 방문하여 탐색을 시작
            - ![](./img/2022-03-13-10-32-48.png)
    6. F섬에 방문하여 탐색을 시작
            - ![](./img/2022-03-13-10-33-14.png)
            - 목적지 F에 도착하였다. 경로의 길이는 2이다.
            - ![](./img/2022-03-13-10-33-39.png)

    ##### DFS: 최대한 깊숙한 곳까지 탐색하기 (깊이 우선 탐색)

    1. A 섬에 방문한 상태 (stack에 담겨져 있음)
            - ![](./img/2022-03-13-10-44-31.png)
    2. B 섬에 방문
            - ![](./img/2022-03-13-10-45-12.png)
    3. D 섬에 방문
            - ![](./img/2022-03-13-10-45-40.png)
            - 더 이상 뻗어 나갈 곳이 없다.
            - D를 스택에서 `pop`
    4. B 섬에 돌아와서 C 섬에 방문
            - ![](./img/2022-03-13-10-47-38.png)
            - ![](./img/2022-03-13-10-48-22.png)
            - 여기서, BFS와 차이점이 지웅이는 경로 2번을 거쳐야지만 C섬으로 올 수 있다. (BFS는 1번만 거치면 C섬으로 올 수 있다고 알려주었다.)
    5. F 섬에 방문
            - ![](./img/2022-03-13-10-50-00.png)
            - 방문순서는 스택에 담겨져 있는 순서의 역순으로 기록(trace)되어 있다.
            - ![](./img/2022-03-13-10-50-47.png)
            - `F, C, B, A` 가 방문 순서가 된다.
            - DFS 알고리즘은 경로를 찾았으나, 최단 경로를 알려주는 것은 아니다.
            - 그러나 경우에 따라서, DFS로 풀어야하는 문제도 등장하기 때문에 DFS도 알아 두어야 한다.

#### 2. 2차원 격자 속 미로 탈출하기
- ![](./img/2022-03-13-11-06-29.png) 
- ![](./img/2022-03-13-11-07-24.png)
- 민영이는 S에서 E로 가고 싶다.
    
    ##### BFS를 활용한 경로탐색(미로찾기)
    
    - `queue` 원소 제거(pop): 좌표 방문
    - `queue` 원소 삽입(push): 좌표 탐색
    1. (1,1)(시작지점)에서 시작
        - ![](./img/2022-03-13-11-13-55.png)
        - ![](./img/2022-03-13-11-14-17.png)
    2. (1,2) 방문
        - 갈 수 있는 곳 없음
    3. (2,1) 방문
        - 탐색
        - ![](./img/2022-03-13-11-15-16.png)
        - ![](./img/2022-03-13-11-15-24.png)
        - 오른쪽으로 (3,1)로만 이동 가능
    4. (3,1) 방문
        - ![](./img/2022-03-13-11-16-12.png)
        - (3,2)로만 이동 가능
        - ![](./img/2022-03-13-11-16-25.png)
    5. (3,2) 방문
        - ![](./img/2022-03-13-11-16-49.png)
        - ![](./img/2022-03-13-11-17-33.png)
        - ![](./img/2022-03-13-11-17-41.png)
    6. (3,3) 방문
        - ![](./img/2022-03-13-11-17-54.png)
        - ![](./img/2022-03-13-11-20-03.png)
        - 목표로 하는 도착 지점(4,3)이 큐에 들어옴
        - ![](./img/2022-03-13-11-19-53.png)
    7. 큐에 있는 나머지 노드에도 방문하여 탐색하고 큐에 push
    8. 도착지점인 (4,3) 방문 차례가 오면 도착지점에 도착하였으니, BFS 종료
        - (1,1)부터 (4,3) 까지 5번의 최단 경로를 찾아냄
        - 실제 방문하여 탐색하는 순서
        - ![](./img/2022-03-13-11-22-21.png)
        
    ##### DFS를 활용한 경로탐색(미로찾기)

    - 스택 원소 제거(`pop`): 이전 위치로 복귀
    - 스택 원소 삽입(`push`): 새로운 좌표 방문
    1. (1,1) 시작지점에서 시작
        - ![](./img/2022-03-13-11-24-25.png)
    2. (1,2)에 방문
        - ![](./img/2022-03-13-11-24-51.png)
        - 갈 곳이 없으니까, 이전 위치로 `pop`
    3. (2,1)에 방문
        - ![](./img/2022-03-13-11-26-11.png)
    4. (3,1)에 방문
        - ![](./img/2022-03-13-11-26-27.png)
        - ![](./img/2022-03-13-11-26-33.png)
    5. (3,2)에 방문
        - ![](./img/2022-03-13-11-26-52.png)
        - ![](./img/2022-03-13-11-27-35.png)
        - 3군데로 이동 가능한데, 위부터 방문한다고 치면 (3,3)으로 이동
    6. (3,3)에 이동
        - ![](./img/2022-03-13-11-27-58.png)
        - 갈 수 있는 경로는 오른쪽 (4,3)
    7. (4,3)에 이동
        - ![](./img/2022-03-13-11-28-31.png)
        - ![](./img/2022-03-13-11-28-37.png)
        - 목적지 도착하였고 이동한 경로는 스택에 담겨져 있는 역순으로 5번의 이동이 발생 (`BFS`와 값 동일한 케이스)

### 2-2. BFS 연습 문제

#### 1. 장기판에서 말을 원하는 곳으로 옮겨라
- 문제 설명: ![](./img/2022-03-13-15-10-48.png)
- 문제 풀이: 
    1. 초기값: 큐에 이동 가능한 좌표(시작 좌표)를 넣는다.
        - ![](./img/2022-03-13-15-15-53.png)
    2. 시작좌표로 부터 이동 가능한 공간을 큐에 넣는다.
        - 노드를 `pop`해서 꺼냄
        - ![](./img/2022-03-13-15-17-34.png)
        - 노드에서 방문 가능한 공간을 큐에 넣는다.
        - ![](./img/2022-03-13-15-19-48.png)
        - 총 8 공간의 이동 가능한 좌표가 큐에 추가된다.
        - ![](./img/2022-03-13-15-20-06.png)
    3. (6,5)부터 방문하여 탐색한다.
        - (6,5) `pop`하여 꺼내기
        - 탐색 공간을 찾고 큐에 넣어주기
        - ![](./img/2022-03-13-15-21-34.png)
        - 이 때, 타겟 좌표인 (4,6)이 큐에 들어와 있음을 볼 수 있다.
    4. (6,3)부터 방문하여 탐색 ...
    5. (4,6)에 방문하여 탐색
        - 목표지점에 도착하였기 때문에 알고리즘 종료

    - 큐에 추가가 되지 않는 조건
        1. 장기판을 벗어난 방문을 하는 경우
        `//장기판 안에 있는 후보지인지 체크:
        if ((next.first >= 1 && next.second >=1) && (next.first <= N && next.second <= M)
        `
        2. 방문한 곳은 또 방문하지 않는다. 비효율 경로를 발생시키기 때문
        `//방문하지 않은 곳인지 체크:
        if (grid[next.first][next.second] == 0)`

- 문제 구현
    - 코드: [BFS_janggi.cpp](./BFS_search/BFS_janggi.cpp)


#### 2. 박스 안에 귤이 모두 상하려면?
- 문제 설명: ![](./img/2022-03-13-16-54-56.png)
![](./img/2022-03-13-16-56-08.png)
- 문제 풀이: 
    1. 시작 값들을 큐에 넣어 준다.
    ![](./img/2022-03-13-17-07-36.png)
        - 상한 귤은 1, 상하지 않은 귤은 0, 비어 있는 공간은 X로 표시한다.
    2. (1,2)를 꺼내고, 이 지점을 기준으로 주변의 상하게 될 귤을 큐에 추가한다.
    ![](./img/2022-03-13-17-09-17.png)
        - 상하게 될 귤의 값은 +1을 해주어 표시한다.
    3. (3,1)를 꺼내고, 이 지점을 기준으로 주변의 상하게 될 귤을 큐에 추가한다.
    ![](./img/2022-03-13-17-09-50.png)
    4. (4,3)을 꺼내고, 이 지점을 기준으로 주변의 상하게 될 귤을 큐에 추가한다.
    ![](./img/2022-03-13-17-10-23.png)
    5. (1,3)을 꺼내고, 이 지점을 기준으로 주변의 상하게 될 귤을 큐에 추가한다.
    6. 큐가 모두 비워질 때 까지 반복한다.
    7. 큐가 모두 비워졌다면, 큐를 순회하며 최대값을 리턴한다. 
        - 리턴되는 값의 -1을 한 것이 귤이 전부 상하게 될 때 까지 걸리는 날짜이다.
        - 순회 중에 `0`의 값이 발견된다면, 모든 귤이 상하지 않았다는 의미가 되므로 문제의 조건대로 `-1`을 리턴한다.
- 문제 구현
    - 코드: [BFS_orange.cpp](./BFS_search/BFS_orange.cpp)



### 2-3. DFS 연습 문제

#### 1. 아파트 단지
- 문제 설명: ![](./img/2022-03-14-16-08-42.png)
![](./img/2022-03-14-16-10-18.png)

- 문제 개념 풀이: 아래와 같이 배열을 식별할 수 있으면, 인접한 모든 아파트를 식별하는 문제를 풀 수 있다.![](./img/2022-03-14-16-11-56.png)

- DFS함수 작동원리
    1. 호출 스택(call stack)에 대해서 짚고 갑시다.
        - 일반적인 함수 호출    
            ```c
            int main(){
                printf("-143의 절대값은: ?%d\n", abs(-143));
            }
            ```
            - 호출순서는 `main`->`printf`->`abs`
            - 종료순서는 `abs`->`printf`->  `main`
            - ![](./img/2022-03-14-16-16-57.png)

        - 재귀함수(recurrent) 함수 호출
            ```c
            inf f(int n){
                if (n==1) return 1;
                return f(n-1)*n;
            }
            int main(){
                int res = f(4);
                printf("Factorial(4): %d\n", res);
            }
            ```
            - 호출순서는 `f(4)`->`f(3)`->`f(2)`->`f(1)`
            - 종료순서는 `f(1)`->`f(2)`->`f(3)`->`f(4)`
            - ![](./img/2022-03-14-16-22-10.png)

    2. 문제풀이를 위한 DFS 재귀함수
        <details>
        <summary>step에 따른 좌표 탐색 호출 순서</summary>

        - 현재 방문 좌표를 (*)로 표시
        1. 시작점(1,1)
            - (1,1) 좌표에서 DFS 함수 호출됨 
            - ![](./img/2022-03-14-16-24-09.png)
            - ![](./img/2022-03-14-16-24-30.png)
        2. (-1,0)만큼 이동하여 (0,1)
            - ![](./img/2022-03-14-16-25-23.png)
            - 갈수 있는 공간이 없음
            - ![](./img/2022-03-14-16-25-40.png)
        3. (1,1)로 돌아옴
            - ![](./img/2022-03-14-16-31-26.png)
        4. (1,2)로 이동하여 DFS 호출
            - ![](./img/2022-03-14-16-31-54.png)
            - 이동할 수 있는 공간 발견
        5. (2,2)로 이동
            - ![](./img/2022-03-14-16-32-17.png)
            - 이동할 수 있는 공간 발견
        6. (2,3)으로 이동
            - ![](./img/2022-03-14-16-32-38.png)
        7. 계속해서 이동할 수 있는 공간으로 이동 ...
            - ![](./img/2022-03-14-16-33-08.png)
            - ![](./img/2022-03-14-16-33-15.png)
            - 더 이상 올라갈 수 있는 공간 없음
        8. 이전 지점으로 돌아감 (호출 스택에서 제거)
        9. (2,2) 지점에서 갈 수 있는 지점 발견하여 이동 (3,2)
            - ![](./img/2022-03-14-16-34-43.png)
            - ![](./img/2022-03-14-16-34-53.png)
        10. 더 이상 갈 수 있는 경로가 없어 이전 지점으로 돌아감(호출 스택에서 제거)
        11. (1,1) 지점에서 갈 수 있는 지점 발견하여 이동 (1,0)
            - ![](./img/2022-03-14-16-36-12.png)
        12. 더 이상 갈 수 있는 곳이 없음
        13. 스택에서 모든 것이 제거됨... 
        14. 깊이 노드의 끝까지 탐색 완료
        </details>

    3. 구현할 DFS함수 프로토타입:
        - ![](./img/2022-03-14-16-40-15.png)
        - 범위를 벗어나가서, 방문한 곳이거나, 아파트가 없는곳에 방문하면 dfs함수가 종료되고, 그렇지 않은 경우에 해당좌표를 `2`로 식별하고, 계속적으로 탐색함
- 문제 구현 
    - 코드: [DFS_apartment.cpp](./DFS_search/DFS_apartment.cpp)

#### 2. 욕심쟁이 조이: DFS와 DP의 결합

- 문제 설명: ![](./img/2022-03-16-00-39-21.png)

- 문제 풀이:
    - 1번 아파트 문제와 마찬가지로 `DFS`를 써서 풀 수 있다.
    - `DFS`만으로만 문제를 풀면 모든 cell에 대하여 DFS알고리즘이 작동하여 함수 실행 횟수가 너무 많이 늘어나 시간초과가 발생할 수 있으므로, DP(동적프로그래밍)기법을 활용하여 문제풀이 시간을 줄여야 한다.
    - 문제 풀이 정리
        - ![](./img/2022-03-16-00-32-25.png)
        - ![](./img/2022-03-16-01-02-45.png)
        1. DFS 함수 사용
            - 모든 위치에 DFS 함수 적용 (아파트 문제와 동일)
            - 확산 조건: 현재 위치 딸기 < 다음 위치 딸기
        2. 연산 횟수 줄이기
            - Top-down 접근 이해: 동적 프로그래밍 기법 활용
            - 메모이제이션(`Memoization`)   

- 문제 구현
    - DP와 DFS의 결합: ![](./img/2022-03-16-01-01-12.png)
    - 코드: [DFS_strawbery_joy.cpp](./DFS_search/DFS_strawbery_joy.cpp)

---
## END & Reference
1. [c언어 문법위키](https://wikidocs.net/book/1411)
